#
# WekaIO Kickstart file
#
#  vince@weka.io
#
# Note:
# /run/install/repo/ is the ISO disk image
# /mnt/sysroot/      is the system image that's been installed

#  Note that the MINIMUM size of the boot disk is 111GB!

# PRE INSTALL SECTION
%pre --logfile=/mnt/sysimage/root/ks-pre.log --erroronfail

# debug file
DEBUGFILE=/tmp/ks.debug

echo "Searching for SSDs" >> $DEBUGFILE
# Look for SSDs that we could use for boot drives
PBOOTSSDS=`lsblk -b -d -o NAME,SIZE,ROTA,TYPE -n | sort -n --key=2 | grep disk | while read NAME SIZE ROTA TYPE; do
GB_CAP=$[SIZE/1024/1024/1024]
# we want only HDDs that are more than 111GB and less than 1.5TB in size
if [ $GB_CAP -lt 1500 ] && [ $GB_CAP -ge 111 ] && [ $ROTA == "0" ]; then
    echo $NAME
        echo "$NAME - $GB_CAP" >> $DEBUGFILE
fi
done | head -2`

echo "Searching for Disks" >> $DEBUGFILE
PBOOTDISKS=`lsblk -b -d -o NAME,SIZE,ROTA,TYPE -n | sort -n --key=2 | grep disk | while read NAME SIZE ROTA TYPE; do
GB_CAP=$[SIZE/1024/1024/1024]
# we want only HDDs that are more than 111GB and less than 1.5TB in size
if [ $GB_CAP -lt 1500 ] && [ $GB_CAP -ge 111 ] && [ $ROTA == "1" ]; then
    echo $NAME
        echo "$NAME - $GB_CAP" >> $DEBUGFILE
fi
done | head -2`

echo "Boot SSDs found:" >> $DEBUGFILE
echo $PBOOTSSDS >> $DEBUGFILE
echo $PBOOTDISKS >> $DEBUGFILE

# make a comma-separated list (we'll need that later)
BOOTSSDS=`echo $PBOOTSSDS | sed 's/ /,/g'`
BOOTDISKS=`echo $PBOOTDISKS | sed 's/ /,/g'`

echo "bootable SSDs:" >> $DEBUGFILE
echo $BOOTSSDS >> $DEBUGFILE
echo $BOOTDISKS >> $DEBUGFILE

# check to see if there are more than one
SSD_IND=`expr index "$BOOTSSDS" ,`
DISK_IND=`expr index "$BOOTDISKS" ,`

echo "indexes:" >> $DEBUGFILE
echo $SSD_IND >> $DEBUGFILE
echo $DISK_IND >> $DEBUGFILE

# prefer SSDs
if [ "$BOOTSSDS" != "" ]; then
        INDEX=$SSD_IND
        BOOTDEVS=$BOOTSSDS
else
        INDEX=$DISK_IND
        BOOTDEVS=$BOOTDISKS
fi

if [ $INDEX -eq 0 ]; then
        # have only one boot device
        BDEV1=$BOOTDEVS
        BDEV2=""
else
        BDEV1=${BOOTDEVS:0:$((INDEX-1))}
        BDEV2=${BOOTDEVS:$INDEX}
fi

echo "boot devices:" >> $DEBUGFILE
echo $BDEV1 >> $DEBUGFILE
echo $BDEV2 >> $DEBUGFILE


if [ "${BOOTDISKS}${BOOTSSDS}" == "" ]; then
    whiptail --infobox --title "DRIVE DETECTION" "NO Drives Detected!" 10 40 > /dev/console
    sleep 10
fi

PART=/tmp/part-include

#for DEV in $BDEV1 $BDEV2; do
#    /usr/bin/dd bs=512 count=10 if=/dev/zero of=/dev/$DEV
#    /usr/sbin/parted --script /dev/$DEV mklabel gpt
#    /usr/sbin/parted --script /dev/$DEV print >> $DEBUGFILE
#done
#/usr/bin/sleep  30

# wipe the drives, if any partitions exist
echo "ignoredisk --only-use=$BOOTDEVS" >> $PART
echo "clearpart --drives=$BOOTDEVS --all --initlabel --disklabel=gpt" >> $PART
#echo "clearpart --all --initlabel --disklabel gpt" >> $PART
#echo "clearpart --all" >> $PART
echo "zerombr" >> $PART

# did the user boot this disk from BIOS boot or EFI boot?
if [ -d /sys/firmware/efi/ ]; then
    EFIBOOT="true"
else
    EFIBOOT="false"
fi

# if we have 2 boot devices, make a raid
if [ "$BDEV2" != "" ]; then
    # RAID for /boot
    echo "part raid.1 --size=300 --asprimary --ondrive=$BDEV1" >> $PART
    echo "part raid.2 --size=300 --asprimary --ondrive=$BDEV2" >> $PART

    if [ $EFIBOOT == "true" ]; then
        # RAID for /boot/efi
        echo "part raid.3 --size=300 --ondrive=$BDEV1" >> $PART
        echo "part raid.4 --size=300 --ondrive=$BDEV2" >> $PART
    fi

    # RAID for /
    echo "part raid.5 --size=50000 --ondrive=$BDEV1" >> $PART
    echo "part raid.6 --size=50000 --ondrive=$BDEV2" >> $PART

    # RAID for /var
    echo "part raid.7 --size=20000 --ondrive=$BDEV1" >> $PART
    echo "part raid.8 --size=20000 --ondrive=$BDEV2" >> $PART

    # RAID for /home
    echo "part raid.9 --size=20000 --ondrive=$BDEV1" >> $PART
    echo "part raid.10 --size=20000 --ondrive=$BDEV2" >> $PART

    # RAID for /opt/
    echo "part raid.11 --size=20000 --grow --ondrive=$BDEV1" >> $PART
    echo "part raid.12 --size=20000 --grow --ondrive=$BDEV2" >> $PART

    # create the raids
    echo "raid /boot --fstype=xfs --device=boot --level=RAID1 raid.1 raid.2" >> $PART

    if [ $EFIBOOT == "false" ]; then
        echo "part biosboot --fstype=biosboot --asprimary --size=1 --ondisk=$BDEV1" >> $PART
    else
        echo "raid /boot/efi --fstype=efi --device=bootefi --level=RAID1 raid.3 raid.4" >> $PART
    fi

    echo "raid / --fstype=xfs --device=root --level=RAID1 raid.5 raid.6" >> $PART
    echo "raid /var --fstype=xfs --device=var --level=RAID1 raid.7 raid.8" >> $PART
    echo "raid /home --fstype=xfs --device=home --level=RAID1 raid.9 raid.10" >> $PART
    #echo "part /opt --fstype=xfs --ondisk=$BDEV1 --size=20000 --grow " >> $PART
    echo "raid /opt--fstype=xfs --device=weka --level=RAID1 raid.11 raid.12" >> $PART
    #echo "bootloader --append="crashkernel=auto" --location=mbr --driveorder=$BOOTDEVS " >> $PART
    echo "bootloader --append='clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable initcall_blacklist=ehci_pci_init initcall_blacklist=ehci_hcd_init' --location=mbr --driveorder=$BOOTDEVS " >> $PART

else    # only 1 boot device, so just make partitions
    # create the parts
    # /boot 		30M
    # /boot/efi		30M
    # /			50G
    # /var		20G
    # /home		20G
    # /opt		20G minimum
    # TOTAL		~111GB

    echo "part /boot --fstype=xfs --ondisk=$BDEV1 --size=300 " >> $PART
    if [ $EFIBOOT == "false" ]; then
        echo "part biosboot --fstype=biosboot --asprimary --size=1 --ondisk=$BDEV1" >> $PART
    else
        echo "part /boot/efi --fstype=efi --ondisk=$BDEV1 --size=300 " >> $PART
    fi
    echo "part / --fstype=xfs --ondisk=$BDEV1 --size=50000 " >> $PART
    echo "part /var --fstype=xfs --ondisk=$BDEV1 --size=20000 " >> $PART
    echo "part /home --fstype=xfs --ondisk=$BDEV1 --size=20000 " >> $PART
    echo "part /opt --fstype=xfs --ondisk=$BDEV1 --size=20000 --grow " >> $PART
    #echo "bootloader --append="crashkernel=auto" --location=mbr --boot-drive=$BDEV1" >> $PART
    echo "bootloader --append='clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable initcall_blacklist=ehci_pci_init initcall_blacklist=ehci_hcd_init' --location=mbr --boot-drive=$BDEV1" >> $PART
fi

%end
# END OF PRE INSTALL SECTION


# License agreement
eula --agreed

# Reboot after installation
reboot
#reboot --eject

# Use text mode install
graphical
#text

# Installation logging level
logging --level=debug

# add repos
#repo --name="OFED58" --baseurl=file:///run/install/repo/OFED58
repo --name="Weka" --baseurl=file:///run/install/repo/Weka
repo --name="LTS" --baseurl=file:///run/install/repo/LTS
repo --name="docker-ce" --baseurl=file:///run/install/repo/docker-ce

repo --name="BaseOS" --baseurl=file:///run/install/sources/mount-0000-cdrom/BaseOS
repo --name="AppStream" --baseurl=file:///run/install/sources/mount-0000-cdrom/AppStream

# built in the %pre (above) - partition the drives
%include /tmp/part-include


# PACKAGES SECTION
%packages
@core
@base
#@anaconda-tools
@performance
@network-tools
#@large-systems
@hardware-monitoring
bind-utils
#elfutils-libelf-devel
gcc
glibc-devel
glibc-headers
ipmitool
#kernel-devel
#kexec-tools
make
#nvme-cli
perl
#rpcbind
xfsprogs
python3
yum-utils
sysstat
telnet
nmap
git
sshpass
lldpd
fio
#numactl
#numactl-devel
libaio-devel
hwloc
#nfs-utils
tmux
conntrack-tools
socat
open-vm-tools
librdmacm
iptables-ebtables
rocky-release
rocky-repos
rocky-gpg-keys
ansible-core

# docker
containerd.io
docker-ce
docker-ce-cli
docker-ce-rootless-extras
docker-compose-plugin
docker-scan-plugin

## ofed below
#dump_pr
#hcoll
#ibutils2
#infiniband-diags
#kmod-kernel-mft-mlnx
#kmod-knem
#libibumad
#libibverbs
#libibverbs-utils
#librdmacm
#librdmacm-utils
#libxpmem
#libxpmem-devel
#mft
#mlnx-ethtool
#mlnx-iproute2
#mlnx-ofed-dpdk
#mlnx-tools
#mpi-selector
#mpitests_openmpi
#mstflint
#ofed-scripts
#openmpi
#opensm
#opensm-devel
#opensm-libs
#perftest
#rdma-core
#rdma-core-devel
#sharp

#Weka
pdsh
pdsh-rcmd-ssh
pdsh-mod-dshgroup
tmate
iperf
htop
nload
screen
ice
%end
# END OF PACKAGES SECTION

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'

# System language
lang en_US.UTF-8

# Firewall configuration
#firewall --disabled
# enable ssh, nfs, smb, weka, and s3, http & https
firewall --enabled --ssh --service=nfs --service=nfs3 --service=samba --port=14000-15000:tcp --port=14000-15000:udp --port=9001:tcp --port=80:tcp --port=443:tcp

# Network information
network  --bootproto=dhcp --device=link --activate --hostname=weka-beta-os.localdomain

# Use CDROM installation media
cdrom

# SELinux configuration
selinux --disabled

# Run the Setup Agent on first boot
firstboot --disable
#firstboot --reconfig

# Do not configure the X Window System
skipx

# System services
#services --enabled="chronyd"

# System timezone
timezone America/New_York

# Root password
rootpw --iscrypted $6$h5gnhpvzLQQn89ji$fZ0/2xwPuGaA/ykDmS6LPOwhe.FUgICZZIS/N1nxQe.cYvUskc7iMpkSwefM7m6jaixb/o3e2Qmb5T58Eu0G31
user --groups=wheel --name=weka --password=$1$f6qOrfA0$X1nJLq3BXYkJAJ.LSMPc11 --iscrypted

#%addon com_redhat_kdump --enable --reserve-mb='auto'
#%end


# POST INSTALL SECTION
%post --nochroot --log=/mnt/sysimage/root/ks-post.log

echo 
echo Welcome to Weka! 
echo 
echo Copying Weka Bits to /opt... 

# copy weka bits to the new system
cp -r /run/install/repo/wekabits /mnt/sysimage/opt/
echo Copy complete. 

# unpack LWH and tools here?
cd /mnt/sysimage/opt
tar xvf wekabits/local-weka-home-bundle.tgz
tar xvf wekabits/tools*gz

# install weka-install service so weka installs on firstboot
chroot /mnt/sysimage /opt/wekabits/firstboot-setup

# add kernel cmdline args
#chroot /mnt/sysimage /usr/sbin/grubby --update-kernel=ALL --args="clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable"
#chroot /mnt/sysimage /usr/sbin/grub2-mkconfig -o /etc/grub2.cfg

# enable docker so it comes up right away
chroot /mnt/sysimage systemctl enable docker.socket

# disable the irq reservation on the i2c_i801 module
cp /mnt/sysimage/opt/wekabits/i2c_i801.conf /mnt/sysimage/etc/modprobe.d/

# copy install logs to new system
cp -r /tmp /mnt/sysroot/root/install-logs

echo All Done!

%end
# END OF POST INSTALL SECTION



