#
# WekaIO Kickstart file
#
#  vince@weka.io
#
# Note:
# /run/install/repo/ is the ISO disk image
# /mnt/sysroot/      is the system image that's been installed

#  Note that the MINIMUM size of the boot disk is 111GB!

# PRE INSTALL SECTION
%pre --logfile=/tmp/ks-pre.log --erroronfail


# find the 2 smallest drives in the system that are the same size, in case we should have mirrored boot drives (may be only one)
echo Starting boot drive selection process

# we need a temp file because just piping the first while loop into the second creates a subshell and the ARRAYs won't be set
TMPFILE=$(mktemp)
echo $TMPFILE
lsblk -b -d -o NAME,SIZE,ROTA,TYPE -n | sort -n --key=2 | grep disk | while read NAME SIZE ROTA TYPE; do
	GB_CAP=$[SIZE/1024/1024/1024]
	#echo $GB_CAP
	# we want only HDDs that are more than 111GB and less than 1.5TB in size
	echo ${NAME} ${GB_CAP}
done | head -2 > $TMPFILE


NAME_ARRAY=()
SIZE_ARRAY=()
while read NAME SIZE; do
	echo $NAME $SIZE
	NAME_ARRAY+=($NAME)
	SIZE_ARRAY+=($SIZE)
done  < $TMPFILE
echo name array is ${NAME_ARRAY[@]}
echo size array is ${SIZE_ARRAY[@]}

# we're done with the temp file now
rm -f $TMPFILE

if [ ${#SIZE_ARRAY[@]} -eq 1 ]; then
	# only one boot drive
	echo only one boot drive
	BDEV1=${NAME_ARRAY[0]} 
	BDEV2=""
else
	echo There are two+ drives in the system
	if [ ${SIZE_ARRAY[0]} != ${SIZE_ARRAY[1]} ]; then
		# different size drives, so use the first (smaller) one
		echo different size drives, using smaller one
		BDEV1=${NAME_ARRAY[0]} 
		BDEV2=""
	else
		echo boot drive mirroring enabled
		BDEV1=${NAME_ARRAY[0]} 
		BDEV2=${NAME_ARRAY[1]}
	fi
fi

echo Boot devices are $BDEV1 and $BDEV2
echo
# need these as a comma-separated list for the partitioning commands below
BOOTDEVS=`echo $BDEV1 $BDEV2 | sed 's/ /,/g'`


# build the part-include file that gets used later in the %include directive 
PART=/tmp/part-include


# wipe the drives, if any partitions exist
echo 'Wiping the boot drive(s)'
echo "ignoredisk --only-use=$BOOTDEVS" >> $PART
echo "clearpart --drives=$BOOTDEVS --all --initlabel --disklabel=gpt" >> $PART
echo "zerombr" >> $PART

# did the user boot this disk from BIOS boot or EFI boot?
if [ -d /sys/firmware/efi/ ]; then
    echo This is an EFI boot system
    EFIBOOT="true"
else
    echo This is an BIOS boot system
    EFIBOOT="false"
fi

# if we have 2 boot devices, make a raid
if [ "$BDEV2" != "" ]; then
    echo Setting up mirrored root
    # RAID for /boot
    echo "part raid.1 --size=300 --asprimary --ondrive=$BDEV1" >> $PART
    echo "part raid.2 --size=300 --asprimary --ondrive=$BDEV2" >> $PART

    if [ $EFIBOOT == "true" ]; then
        # RAID for /boot/efi
        echo "part raid.3 --size=300 --ondrive=$BDEV1" >> $PART
        echo "part raid.4 --size=300 --ondrive=$BDEV2" >> $PART
    fi

    # RAID for /
    echo "part raid.5 --size=50000 --ondrive=$BDEV1" >> $PART
    echo "part raid.6 --size=50000 --ondrive=$BDEV2" >> $PART

    # RAID for /var
    echo "part raid.7 --size=20000 --ondrive=$BDEV1" >> $PART
    echo "part raid.8 --size=20000 --ondrive=$BDEV2" >> $PART

    # RAID for /home
    echo "part raid.9 --size=20000 --ondrive=$BDEV1" >> $PART
    echo "part raid.10 --size=20000 --ondrive=$BDEV2" >> $PART

    # RAID for /opt/
    echo "part raid.11 --size=20000 --grow --ondrive=$BDEV1" >> $PART
    echo "part raid.12 --size=20000 --grow --ondrive=$BDEV2" >> $PART

    # create the raids
    echo "raid /boot --fstype=xfs --device=boot --level=RAID1 raid.1 raid.2" >> $PART

    if [ $EFIBOOT == "false" ]; then
        echo "part biosboot --fstype=biosboot --asprimary --size=1 --ondisk=$BDEV1" >> $PART
    else
        echo "raid /boot/efi --fstype=efi --device=bootefi --level=RAID1 raid.3 raid.4" >> $PART
    fi

    echo "raid / --fstype=xfs --device=root --level=RAID1 raid.5 raid.6" >> $PART
    echo "raid /var --fstype=xfs --device=var --level=RAID1 raid.7 raid.8" >> $PART
    echo "raid /home --fstype=xfs --device=home --level=RAID1 raid.9 raid.10" >> $PART
    #echo "part /opt --fstype=xfs --ondisk=$BDEV1 --size=20000 --grow " >> $PART
    echo "raid /opt--fstype=xfs --device=weka --level=RAID1 raid.11 raid.12" >> $PART
    #echo "bootloader --append="crashkernel=auto" --location=mbr --driveorder=$BOOTDEVS " >> $PART
    echo "bootloader --append='clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable initcall_blacklist=ehci_pci_init initcall_blacklist=ehci_hcd_init' --location=mbr --driveorder=$BOOTDEVS " >> $PART

else    # only 1 boot device, so just make partitions
    # create the parts
    # /boot 		30M
    # /boot/efi		30M
    # /			50G
    # /var		20G
    # /home		20G
    # /opt		20G minimum
    # TOTAL		~111GB

    echo Setting up for single boot device

    echo "part /boot --fstype=xfs --ondisk=$BDEV1 --size=300 " >> $PART
    if [ $EFIBOOT == "false" ]; then
        echo "part biosboot --fstype=biosboot --asprimary --size=1 --ondisk=$BDEV1" >> $PART
    else
        echo "part /boot/efi --fstype=efi --ondisk=$BDEV1 --size=300 " >> $PART
    fi
    echo "part / --fstype=xfs --ondisk=$BDEV1 --size=50000 " >> $PART
    echo "part /var --fstype=xfs --ondisk=$BDEV1 --size=20000 " >> $PART
    echo "part /home --fstype=xfs --ondisk=$BDEV1 --size=20000 " >> $PART
    echo "part /opt --fstype=xfs --ondisk=$BDEV1 --size=20000 --grow " >> $PART
    #echo "bootloader --append="crashkernel=auto" --location=mbr --boot-drive=$BDEV1" >> $PART
    echo "bootloader --append='clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable initcall_blacklist=ehci_pci_init initcall_blacklist=ehci_hcd_init' --location=mbr --boot-drive=$BDEV1" >> $PART
fi

echo
echo Partitions set.  Partition commands are:
cat $PART

%end
# END OF PRE INSTALL SECTION


# License agreement
eula --agreed

# Reboot after installation
reboot
#reboot --eject

# Use text mode install
graphical
#text

# Installation logging level
logging --level=debug

# add repos
#repo --name="OFED58" --baseurl=file:///run/install/repo/OFED58
repo --name="Weka" --baseurl=file:///run/install/repo/Weka
repo --name="LTS" --baseurl=file:///run/install/repo/LTS
repo --name="docker-ce" --baseurl=file:///run/install/repo/docker-ce

repo --name="BaseOS" --baseurl=file:///run/install/sources/mount-0000-cdrom/BaseOS
repo --name="AppStream" --baseurl=file:///run/install/sources/mount-0000-cdrom/AppStream

# built in the %pre (above) - partition the drives
%include /tmp/part-include


# PACKAGES SECTION
%packages
@core
@base
#@anaconda-tools
@performance
@network-tools
#@large-systems
@hardware-monitoring
bind-utils
#elfutils-libelf-devel
gcc
glibc-devel
glibc-headers
ipmitool
#kernel-devel
#kexec-tools
make
#nvme-cli
perl
#rpcbind
xfsprogs
python3
yum-utils
sysstat
telnet
nmap
git
sshpass
lldpd
fio
#numactl
#numactl-devel
libaio-devel
hwloc
#nfs-utils
tmux
conntrack-tools
socat
open-vm-tools
librdmacm
iptables-ebtables
rocky-release
rocky-repos
rocky-gpg-keys
ansible-core

# docker
containerd.io
docker-ce
docker-ce-cli
docker-ce-rootless-extras
docker-compose-plugin
docker-scan-plugin

## ofed below
#dump_pr
#hcoll
#ibutils2
#infiniband-diags
#kmod-kernel-mft-mlnx
#kmod-knem
#libibumad
#libibverbs
#libibverbs-utils
#librdmacm
#librdmacm-utils
#libxpmem
#libxpmem-devel
#mft
#mlnx-ethtool
#mlnx-iproute2
#mlnx-ofed-dpdk
#mlnx-tools
#mpi-selector
#mpitests_openmpi
#mstflint
#ofed-scripts
#openmpi
#opensm
#opensm-devel
#opensm-libs
#perftest
#rdma-core
#rdma-core-devel
#sharp

#Weka
pdsh
pdsh-rcmd-ssh
pdsh-mod-dshgroup
tmate
iperf
htop
nload
screen
ice
%end
# END OF PACKAGES SECTION

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'

# System language
lang en_US.UTF-8

# Firewall configuration
#firewall --disabled
# enable ssh, nfs, smb, weka, and s3, http & https
firewall --enabled --ssh --service=nfs --service=nfs3 --service=samba --port=14000-15000:tcp --port=14000-15000:udp --port=9001:tcp --port=80:tcp --port=443:tcp

# Network information
network  --bootproto=dhcp --device=link --activate --hostname=weka-beta-os.localdomain

# Use CDROM installation media
cdrom

# SELinux configuration
selinux --disabled

# Run the Setup Agent on first boot
firstboot --disable
#firstboot --reconfig

# Do not configure the X Window System
skipx

# System services
#services --enabled="chronyd"

# System timezone
timezone America/New_York

# Root password
rootpw --iscrypted $6$h5gnhpvzLQQn89ji$fZ0/2xwPuGaA/ykDmS6LPOwhe.FUgICZZIS/N1nxQe.cYvUskc7iMpkSwefM7m6jaixb/o3e2Qmb5T58Eu0G31
user --groups=wheel --name=weka --password=$1$f6qOrfA0$X1nJLq3BXYkJAJ.LSMPc11 --iscrypted

#%addon com_redhat_kdump --enable --reserve-mb='auto'
#%end


# POST INSTALL SECTION
%post --nochroot --log=/mnt/sysimage/root/ks-post.log

echo 
echo Welcome to Weka! 
echo 
echo Copying Weka Bits to /opt... 

# copy weka bits to the new system
cp -r /run/install/repo/wekabits /mnt/sysimage/opt/
echo Copy complete. 

# unpack LWH and tools here?
cd /mnt/sysimage/opt
tar xvf wekabits/local-weka-home-bundle.tgz
tar xvf wekabits/tools*gz

# install weka-install service so weka installs on firstboot
chroot /mnt/sysimage /opt/wekabits/firstboot-setup

# add kernel cmdline args
#chroot /mnt/sysimage /usr/sbin/grubby --update-kernel=ALL --args="clocksource=tsc tsc=reliable nomodeset intel_iommu=off intel_idle.max_cstate=0 processor.max_cstate=0 numa_balancing=disable"
#chroot /mnt/sysimage /usr/sbin/grub2-mkconfig -o /etc/grub2.cfg

# enable docker so it comes up right away
chroot /mnt/sysimage systemctl enable docker.socket

# disable the irq reservation on the i2c_i801 module
cp /mnt/sysimage/opt/wekabits/i2c_i801.conf /mnt/sysimage/etc/modprobe.d/

# copy install logs to new system
cp -r /tmp /mnt/sysroot/root/install-logs

echo All Done!

%end
# END OF POST INSTALL SECTION



